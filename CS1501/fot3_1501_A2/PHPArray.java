import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.Stack;

/**
 * Created by forbes on 6/9/17.
 */
public class PHPArray<V> implements Iterable<V> {

    private int M;
    private int N = 0;
    private Node<V> lastNode;
    private  Node<V> firstNode;
    private  Node<V> currentNode;
    private Node<V>[] table;

    @SuppressWarnings("unchecked")
    public PHPArray(int initialSize) {
        table=new Node[initialSize];
        M = initialSize;
    }

    // Default constructor
    @SuppressWarnings("unchecked")

    public PHPArray() {
        table=new Node[10];
        M = 10;
    }

    public void put(int key, V val) {
        put(Integer.toString(key), val);
    }

    public V get(int key) {
        return get(Integer.toString(key));
    }

    /*
     * Creates a new node, and links it into the linkedList appropriately as well as places it into the
     * array containing nodes
     */
    public void put(String key, V val) {
        if (val == null) unset(key);

        // double table size if 50% full
        if (N >= M / 2) resize(2 * M);

        int i;
        for (i = hash(key); (table[i] != null); i = (i + 1) % M) {
            if (table[i].key.equals(key)) {
                table[i].val = val;
                return;
            }
        }
        table[i] = new Node<V>();
        table[i].key = key;
        table[i].val = val;

        if (N == 0) {
            firstNode = table[i];
            lastNode = firstNode;
            currentNode = firstNode;
        } else {
            lastNode.nextNode = table[i];
            table[i].previousNode = lastNode;
            lastNode = table[i];
        }
        N++;
    }

    // Rehashes every element in the table
    @SuppressWarnings("unchecked")

    private void rehash(Node<V> node) {
        System.out.println("\t\tKey " + node.key + " rehashed...\n");
        if (node.val == null) unset(node.key);

        int i;
        for (i = hash(node.key); table[i] != null; i = (i + 1) % M) {
            if (table[i].key.equals(node.key)) {
                table[i].val =node.val;
                return;
            }
        }
        table[i] = node;
    }

    // Returns the element located at the hash code generated by the key or in the same cluster
    @SuppressWarnings("unchecked")
    public V get(String key) {
        for (int i = hash(key); table[i] != null; i = (i + 1) % M) {
            if (table[i].key.equals(key))
                return table[i].val;
        }
        return null;
    }

    // Returns number of elements present in the table
    public int length()
    {
        return N;
    }

    public boolean isEmpty() {
        return length() == 0;
    }

    public boolean contains(String key) {
        return get(key) != null;
    }

    /* Resize the table based on input capacity. Note that this does not actually increase the capacity
     * parameter internally
     */
    private void resize(int capacity) {

        System.out.println("\t\tSize: " + N + " -- resizing array from " + M + " to " + (M*2));
        PHPArray<V> temp = new PHPArray<>(capacity);
        int tempM = M;
        M = temp.M;

        for (int i = 0; i < tempM; i++) {
            if (table[i] != null) {
                temp.table[hash(table[i].key)] = table[i];
            }
        }
        table = temp.table;
    }

    /* Delete the key (and associated value) from the symbol table. Also remove any references to the deleted
     * node, and rehash the nodes in the same cluster
     */
    @SuppressWarnings("unchecked")
    public void unset(String key) {

        if (!contains(key)) return;

        // find position i of key
        int i = hash(key);
        while (!table[i].key.equals(key)) {
            i = (i + 1) % M;
        }

        // delete key and associated value
        if (table[i].previousNode != null)
            table[i].previousNode.nextNode = table[i].nextNode;
        if (table[i].nextNode != null)
            table[i].nextNode.previousNode = table[i].previousNode;

        if (firstNode == table[i] && firstNode != lastNode) {
            firstNode = table[i].nextNode;
            currentNode = firstNode;
            table[i].nextNode.previousNode = null;
        }
        if (lastNode == table[i] && lastNode != firstNode) {
            lastNode = table[i].previousNode;
            table[i].previousNode.nextNode = null;
        }

        table[i] = null;

        // rehash all keys in same cluster
        i = (i + 1) % M;
        while (table[i] != null) {
            // delete keys[i] an vals[i] and reinsert
            Node<V> nodeToRehash = table[i];
            table[i] = null;
            rehash(nodeToRehash);
            i = (i + 1) % M;
        }
        N--;
        // halves size of array if it's 12.5% full or less
        if (N > 0 && N <= M / 8) resize(M / 2);
    }

    public void unset(int key) {
        unset(Integer.toString(key));
    }

    private int hash(String key) {
        return (key.hashCode() & 0x7fffffff) % M;
    }

    private static class Node<T>{
        String key;
        T val;
        Node<T> nextNode;
        Node<T> previousNode;
    }

    public static class Pair<T> {
        public String key;
        public T value;
    }

    // Allows for elements in table to be iterated through as a Pair type containing both key and value
    @SuppressWarnings("unchecked")
    public Pair<V> each() {
        Pair<V> pairToReturn;
        if (this.currentNode == null)
            return null;
        else {
            pairToReturn = new Pair<V>();
            pairToReturn.key = this.currentNode.key;
            pairToReturn.value = this.currentNode.val;
            currentNode = this.currentNode.nextNode;
            return pairToReturn;
        }
    }

    // Resets the each method
    public void reset() {
        this.currentNode = firstNode;
    }

    @SuppressWarnings("unchecked")
    public ArrayList<V> values() {
        Node<V> currentLocation = firstNode;
        ArrayList<V> result = new ArrayList<V>();
        while (currentLocation != null) {
            result.add(currentLocation.val);
            currentLocation = currentLocation.nextNode;
        }
        return result;
    }

    public ArrayList<String> keys() {
        Node<V> currentLocation = firstNode;
        ArrayList<String> result = new ArrayList<String>();
        while (currentLocation != null) {
            result.add(currentLocation.key);
            currentLocation = currentLocation.nextNode;
        }
        return result;
    }

    // Prints out all elements in table
    public void showTable() {
        System.out.println("\tRaw Hash Table Contents:");
        for(int i=0;i<table.length;i++) {
            System.out.print(i + ": ");
            if(table[i] != null)
                System.out.println(table[i].key + " Value: " + table[i].val);
            else
                System.out.println("null");
        }
    }

    // Sorts elements in the table based on value, and changes key to indices.
    @SuppressWarnings("unchecked")
    public <T extends Comparable<? super T>> void sort(){
        ArrayList<T> valArray = (ArrayList<T>)values();
        Collections.sort(valArray);
        PHPArray<V> temp = new PHPArray<>(M);

        for(int i=0;i<valArray.size();i++) {
            temp.put(i,(V)valArray.get(i));
        }
        firstNode=temp.firstNode;
        lastNode=temp.lastNode;
        currentNode=firstNode;
        table = temp.table;
    }

    // Sorts elements in the table based on value and leaves key untouched
    @SuppressWarnings("unchecked")
    public <T extends Comparable<? super T>> void asort(){

        ArrayList<CompNode<T>> arraySorter= new ArrayList<>();
        Node<V> currentLocation = firstNode;
        while (currentLocation != null) {
            CompNode<T> temp = new CompNode();
            temp.key=currentLocation.key;

            temp.val=(T)currentLocation.val;
            arraySorter.add(temp);
            currentLocation = currentLocation.nextNode;
        }
        Collections.sort(arraySorter);
        PHPArray<V> temp = new PHPArray<>(M);

        for(int i=0;i<arraySorter.size();i++) {
            temp.put(arraySorter.get(i).key,(V)arraySorter.get(i).val);
        }

        table = temp.table;
        firstNode=temp.firstNode;
        lastNode=temp.lastNode;
        currentNode=firstNode;
    }

    // Helper class for asort so that key, value association remains intact
    private static class CompNode<T extends Comparable<? super T>> implements Comparable<CompNode<T>>{
        String key;
        T val;
        public int compareTo(CompNode<T> tCompNode) {
             return this.val.compareTo(tCompNode.val);
        }
    }



    // Flips table key/value pairs, only can be completed if value type is String
    public PHPArray<String> array_flip(){
        if(!(firstNode.val instanceof String)){
            throw new ClassCastException("Cannot convert class java.lang.Integer to String");
        }

        PHPArray<String> temp = new PHPArray<>(M);
        Node currentLocation = firstNode;
        while (currentLocation != null) {
            temp.put((String)currentLocation.val,currentLocation.key);
            currentLocation=currentLocation.nextNode;
        }
        return temp;
    }

    public Iterator<V> iterator() {
        return values().iterator();
    }

    //Reverses the order of the elements in this PHPArray
    public void rsort(){

        Stack<Node<V>> stack = new Stack<>();

        Node<V> currentLocation = firstNode;
        Node<V> tempNode;
        while (currentLocation != null) {
            stack.push(currentLocation);
            currentLocation = currentLocation.nextNode;
        }

        PHPArray<V> temp = new PHPArray<>(M);
        while ((!stack.isEmpty())) {
            tempNode =  stack.pop();
            temp.put(tempNode.key,tempNode.val);
        }

        table = temp.table;
        firstNode=temp.firstNode;
        lastNode=temp.lastNode;
        currentNode=firstNode;
    }

    //Returns an ArrayList of the values in reverse
    public ArrayList<V> array_reverse(){

        Stack<Node<V>> stack = new Stack<>();

        Node<V> currentLocation = firstNode;
        Node<V> tempNode;
        while (currentLocation != null) {
            stack.push(currentLocation);
            currentLocation = currentLocation.nextNode;
        }

        PHPArray<V> temp = new PHPArray<>(M);
        while ((!stack.isEmpty())) {
            tempNode =  stack.pop();
            temp.put(tempNode.key,tempNode.val);
        }
        return temp.values();
    }

    //Returns an iterator for the reverse order of the array values
    public Iterator reverse_iterator(){

        Stack<Node<V>> stack = new Stack<>();

        Node<V> currentLocation = firstNode;
        Node<V> tempNode;
        while (currentLocation != null) {
            stack.push(currentLocation);
            currentLocation = currentLocation.nextNode;
        }

        PHPArray<V> temp = new PHPArray<>(M);
        while ((!stack.isEmpty())) {
            tempNode =  stack.pop();
            temp.put(tempNode.key,tempNode.val);
        }

        return temp.iterator();
    }


    //Returns the sum of all items in the array if they are numbers
    public Double array_sum(){
        if(!(firstNode.val instanceof Number)){
            throw new ClassCastException("Cannot cast value to number");
        }

        ArrayList<V> temp = values();
        Double total=0.0;
        for(int i=0; i<temp.size();i++)
            total+=((Number)temp.get(i)).doubleValue();
        return total;
    }




}
